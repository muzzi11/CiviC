Program		=>	[Declaration]+

Declaration	=>	extern Dec | export Def

Dec			=> 	Type Id FunHeader FunDec
			| 	Type ArrayId Id GlobalDec
			|	void Id FunHeader FunDec

FunHeader	=>	( Param Params )

Param		=>	Type ArrayId Id | $

Params		=>	, Type ArrayId Id Params | $

FunDec		=>	;

GlobalDec	=>	;

Def			=>	Export Type Id FunHeader FunDef
			|	Export Type Id AssignOpt GlobalDef
			| 	Export Type ArrayExpr Id AssignOpt GlobalDef
			|	Export void FunHeader FunDef

Export		=>	export | $

GlobalDef	=>	;

FunDef		=>	{ FunBody }

Type		=>	bool | int | float

FunBody		=>	Locals Statements Return

Locals		=>	Type Id FunHeader { FunBody } Locals
			|	void Id FunHeader { FunBody } Locals
			|	Type Id AssignOpts ; Locals
			|	Type ArrayExpr Id AssignOpts ; Locals
			|	$

ArrayExpr	=>	[ Expr Exprs ]

ArrayId		=>	[ Id Ids ] | $

Ids			=>	, Id Ids | $

Statement	=>	Id ArrayExpr Assign ;
			|	Id Assign ;
			|	Id ( ) ;
			|	Id ( Expr Exprs ) ;
			|	if ( Expr ) Block ElseBlock
			|	while ( Expr ) Block
			|	do Block while ( Expr ) ;
			|	for ( int Id Assign, Expr Step ) Block

Step		=>	, Expr | $

Block		=>	{ Statements } | Statement

ElseBlock	=>	else Block | $

Statements	=>	Statement Statements | $

Return		=> 	return Expr ; | $

Assign		=> 	= Expr

AssignOpt	=> 	Assign | $

Expr		=>	( Expr )
			|	Expr BinOp Expr
			|	MonOp Expr
			|	( Type ) Expr
			|	Id ( Args )
			|	Id ArrayExpr
			|	Literal
			|	[ Expr Exprs ]
			
Exprs		=>	, Expr Exprs | $

Args		=>	Expr Exprs | $

BinOp		=>	ArithOp | LogicOp | RelOp

ArithOp		=>	ArithOp1 | ArithOp2

Arith1		=>	+ | -

Arith2		=>	* | / | %

RelOp		=>	RelOp1 | RelOp2

RelOp1		=>	== | !=

RelOp2		=>	< | <= | > | >=

LogicOp		=>	LogicOp1 | LogicOp2

LogicOp1	=>	||

LogicOp2	=>	&&

MonOp		=>	- | !

2 * 3 + 6

fun Declaration()
{
	return Extern() && Dec() || Export() && Def() || Def();
}

bool Extern()
{
	if(tokens[t] == Keyword::Extern)
	{
		t++;
		return true;
	}
	
	return false;
}

bool Dec()
{
	return Type() && Id() && (FunDec() || Semicolon()) || 
			Void() && Id && FunDec();
}